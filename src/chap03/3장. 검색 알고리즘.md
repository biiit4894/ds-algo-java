03장. 검색 알고리즘

# 03-1 검색 알고리즘이란?

데이터 집합에서 원하는 값을 가진 요소를 찾아내는 검색 알고리즘

## 검색과 키 살펴보기
1. 찾으려는 키값과 일치하도록 현재 키값을 지정하거나
2. 키값의 구간을 지정하거나
3. 찾으려는 키값과 비슷하도록 현재 키값을 지정한다.

## 배열에서 검색하기
배열에서 검색을 위해 사용하는 알고리즘
1. 선형 검색 : 무작위로 늘어서 있는 데이터 모임에서 검색 수행
2. 이진 검색 : 일정한 규칙으로 늘어서 있는 데이터 모임에서 빠르게 검색 수행
3. 해시법 : 추가, 삭제가 자주 일어나는 데이터 모임에서 빠르게 검색 수행
  - 체인법 : 같은 해시값의 데이터를 선형 리스트로 연결
  - 오픈 주소법 : 데이터를 위한 해시값이 충돌할 때 재해시

# 03-2 선형 검색
## 선형 검색 알아보기
배열의 요소를 맨 앞부터 순서대로 스캔해 검색
요솟수가 n인 배열 a에서 값이 key인 요소를 검색한다면?
```java
int i = 0;

while(true) {
    if(i == n) 
        return -1;  // 검색 실패
    if(a[i] == key)
        return i;   // 검색 성공(인덱스 반환)
    i++;
        
}
```

### 무한 루프의 구현
```java
while(true) {
    
}

for( ; true ; ) {

}

do {

} while (true); // 끝까지 읽어야 무한 루프인지 알 수 있기 때문에 권장 x
```
(SeqSearch.java)

### for문으로 구현
배열 검색을 while문 대신 for문으로 구현하면 코드가 간결해진다. (SeqSearchFor.java)
요소를 순서대로 검색하는 선형 검색은 요소가 정렬되지 않은 배열에서 검색할 때 사용하는 유일한 방법이다. 

## 보초법으로 선형 검색 구현하기


# 03-3 이진 검색
## 이진 검색 알아보기
요소가 오름차순 또는 내림차순으로 정렬된 배열에서 검색
검색 범위의 맨 앞 인덱스: pl <br>
검색 범위의 맨 끝 인덱스: pr <br>
검색 범위의 중앙 인덱스 : pc <br>
검색을 시작할 때 pl은 0, pr은 n-1, pc는 (n-1)/2 <br>

### `a[pc]` < `key`일 때
`pl` 값을 `pc + 1`로 업데이트

### `a[pc]` > `key`일 때
`pr` 값을 `pc - 1`로 업데이트

## 복잡도 구하기
- 복잡도 : 알고리즘의 성능을 객관적으로 평가하는 기준
  - 시간 복잡도 : 실행에 필요한 시간을 평가
  - 공간 복잡도 : 기억 영역과 파일 공간이 얼마나 필요한가를 평가

### 선형 검색의 시간 복잡도
```java
static int seqSearch(int[] a, int n, int key) {
	int i = 0;              // 1회 실행 - O(1)
	
	while(i < n) {          // n/2회 실행 - O(n)
		if(a[i] == key) {   // n/2회 실행 - O(n)
			return i;       // 1회 실행 - O(1)
		}
		i++;                // n/2회 실행 - O(n)
	} 
	return -1;              // 1회 실행 - O(1)
}
```
결론: O(n)

### 이진 검색의 시간 복잡도
```java
static int binSearch(int[] a, int n, int key) {
	int pl = 0;         // 1회 - O(1)
	int pr = n - 1;     // 1회 - O(1)
	
	do {
		int pc = (pl + pr) / 2;     // log n회 - O(log n)
		if(a[pc] == key) {          // log n회 - O(log n)
			return pc;              // 1회 - O(1)
        } else if (a[pc] < key) {   // log n회 - O(log n)
			pl = pc + 1;            // log n 회 - O(log n)
        } else {                    
			pr = pc - 1;            // log n 회 - O(log n)
        }           
    } while(pl <= pr);              // log n 회 - O(log n)
	
	return -1;                      // 1회 - O(1)
}
```

## Arrays.binarySearch에 의한 이진 검색
오름차순으로 정렬된 배열 a를 가정하고 값이 key인 요소를 이진 검색함. 
### 검색에 성공한 경우
key와 일치하는 요소의 인덱스를 반환하지만, key와 일치하는 요소가 여러 개 있을 경우 맨 앞에 있는 요소의 인덱스를 반환한다는 보증은 없음..<br>

### 검색에 실패한 경우
검색에 실패했을 때는 '배열 안에 key가 있어야 할 위치(삽입 포인트)를 추정할 수 있는 값'을 반환한다.<br>
삽입 포인트를 x라고 할 때 반환값은 `-x-1`이다. 검색하기 위해 지정한 key보다 큰 요소 중 첫 번째 요소의 인덱스이다.

**클래스 메서드와 인스턴스 메서드**
- 인스턴스 메서드(비정적 메서드) : static을 붙이지 않고 선언한 메서드로, 그 클래스형의 개별 인스턴스
  - 인스턴스 메서드 호출 : `클래스형 변수 이름.메서드 이름(...)` 
- 클래스 메서드(정적 메서드) : static을 붙여 선언한 메서드로, 특정 인스턴스에 속하지 않음
  - 클래스 메서드 호출 : `클래스 이름.메서드 이름(...)` 

### 객체의 배열에서 검색하기
- `static int binarySearch(Object[] a, Object key)` : 자연 정렬(natural ordering)이 된 배열에서 요소의 대소관계를 판단하고 검색하는 메서드.
  - 정수 배열, 문자열 배열에서 검색할 때 적당하다.
- `static <T> int binarySearch(T[] a, T key, Comparator<? super T> c)` : 자연 정렬이 아닌 순서로 나열된 배열에서 검색하는 메서드
  - 자연 정렬을 논리적으로 갖지 않는 클래스의 배열에서 검색할 때 알맞다. 

**A. 자연 정렬이 된 배열에서 검색하기**<br>
`static int binarySearch(Object[] a, Object key)`<br>
binarySearch 메서드에 배열과 키값을 전달하는 간단한 방법으로 검색할 수 있는 이유는 String 클래스가 Comparable<T> 인터페이스와 compareTo 메서드를 구현하고 있기 때문이다. 다음은 자연 정렬된 상태와 그렇지 않은 상태의 예이다.<br>
- 문자열 정렬(자연정렬되지 않은 상태)
```java
텍스트1.txt
텍스트10.txt
텍스트100.txt
텍스트2.txt
텍스트21.txt()
```
- 자연 정렬
```java
텍스트1.txt
텍스트2.txt
텍스트10.txt
텍스트21.txt
텍스트100.txt
```

**B. 자연 정렬이 되지 않은 배열에서 검색하기**<br>
자연 정렬이 되지 않은 배열에서의 검색은 제네릭 메서드를 사용한다.
`static <T> int binarySearch(T[] a, T key, Comparator <? super T> c)`<br>
제네릭으로 구현한 위의 메소드에서 첫번째 매개변수 a는 검색 대상이고, 두번째 매개변수 key는 키값이다. 제네릭 메서드는 자료형에 구애받지 않는다. 따라서 매개변수로 전달하는 자료형은 Integer, String, 신체검사 데이터용 클래스 PhyscData 등 어떤 것을 전달해도 좋다.<br>
다만 배열 요소가 어떤 순서로 나열되어 있는지, 각 요소의 대소 관계를 어떻게 판단할 것인지 등은 binarySearch 메서드에 알려주어야 한다. 이 정보는 세번째 매개변수 c에 전달된다.<br>

`Comparator<? super T> c`<br>
클래스 T(또는 클래스 T의 상위 클래스)의 두 객체 사이 대소관계를 생성하기 위한 comparator이다. comparator 안에는 compare 메서드가 있다.<br>
comparator의 근원은 다음과 같이 정의된 `java.util.Comparator` 인터페이스이다.

```java
package java.util;
public interface Comparator<T> {
  int compare(T o1, T o2);
  boolean equals(Object obj);
}
```

객체의 대소관계를 판단하는 comparator를 사용자가 직접 구현하려면 Comparator 인터페이스를 구현한 클래스를 정의하고 그 클래스형의 인스턴스를 생성해야 한다. 그런 다음 매개변수로 전달된 두 객체의 대소 관계를 비교해 그 결과를 아래의 값으로 반환하는 compare 메서드를 구현하면 된다.
- 첫 번째 인수가 더 크면 양수
- 첫 번째 인수가 더 작으면 음수
- 첫 번째 인수와 두 번째 인수가 같으면 0



