# 02-1 배열

## 자료구조
- 데이터 단위 : 데이터를 구성하는 한 덩어리
- 자료구조 : 자료를 효율적으로 이용하도록 적재하는 법

## 배열
- 같은 자료형의 변수로 이루어진 구성요소가 모인 것.
- 가령 `int[]a = new int[5];` 의 경우 int형의 배열 본체를 생성하고 배열 a가 그것을 참조하도록 설정하는 것이다. 

### 구성 요소
- 배열 내 모든 구성 요소의 형태는 같고 직선 모양으로 줄지어 있음. 정수형 인덱스로 각 요소에 접근.
- 자동으로 0으로 초기화된다.
- 배열을 생성할 때의 초기값
  - byte형 : (byte)0
  - short형 : (short)0
  - int형 : 0
  - long형 : 0L
  - float형 : 0.0f
  - double형 : 0.0d
  - char형 : `\u0000`
  - boolean형 : false
  - 참조형 : 공백 참조 or null값

### 배열의 길이
- `배열 변수 이름.length`로 길이에 접근

**참고** <br>
배열의 자료형과 배열 각 요소의 자료형은 다르다! 위에 나온 배열 a의 자료형은 int[5]형이지만 각 요소 하나 하나의 자료형은 int형이다. 
<br><br>
**값을 대입하지 않은 지역변수**<br>
메서드 안에서 선언한 지역변수는 변수를 만들어도 초깃값으로 초기화되지 않는다. 
```agsl
int a;
System.out.println(a); // compile error
```

### 배열의 요솟값 초기화
```agsl
int[] a = {1, 2, 3, 4 ,5};
```
배열 본체의 생성과 동시에 요소를 모두 초기화함

### 배열의 복제
`배열 이름.clone()`
가령 이미 초기값 설정까지 완료된 int형이 모인 배열 a를 배열 b가 clone한다면, 배열 변수 b는 a가 참조하는 배열 본체의 **복제**를 참조한다. 

## 배열 요소의 최댓값 구하기
- 주사(traverse, 스캔): 배열의 요소를 하나씩 차례로 살펴보는 과정
  - 데이터를 하나씩 지나면서 살피고 조사하는 것.

배열 모든 요소에 대해 스캔을 완료한 시점에 최대 요솟값을 최대값 변수에 대입하면 된다.

### 배열 요소의 최댓값을 구하는 메서드
**참고 : 메서드의 매개변수로 배열 사용하기** <br>
예제의 `MaxOfArray.java` 코드에서, 마지막의 `maxOf(height)`를 보자. 배열 height의 최댓값을 구하기 위해 maxOf 메서드를 호출한다. 
인수로 들어간 height는 배열 본체를 참조하는 배열 변수이고, maxOf에 전달되는 것은 배열 본체에 대한 참조가 된다. 
maxOf에서는 배열 변수인 매개변수 a가 전달받은 참조로 초기화되고, 배열 변수 a는 배열 height의 본체를 참조한다. 
결과적으로 maxOf 안의 배열 a는 main 메서드의 배열 height인 셈이 된다. 
이로 인해 메서드 maxOf는 매개변수 a가 전달받은 참조 덕분에 배열의 요솟수와 각 요소에 접근할 수 있다.

### 난수를 사용해 배열의 요솟값 설정하기
`MaxOfArrayRand.java` 코드는 배열의 각 요소에 난수를 대입하고 있다. `Random rand = new Random();` 코드로 Random 클래스형의 변수를 만들기 위한 선언을 하고, 
`rand.nextInt(90);`으로 변수 rand에 대한 난수를 생성하는 메소드 `nextInt`를 호출한다. `nextInt(n)`은 0 ~ (n-1)까지의 난수를 반환한다.

**난수의 생성** <br>
java.util 패키지의 Random 클래스. 이 클래스의 인스턴스는 일련의 의사 난수를 생성하고 이 난수는 seed라는 수의 값을 바탕으로 연산과정을 거쳐 도출된다. 
`Random rand = new Random();` 또는 `Random rand = new Random(n)` 방식으로 Random 클래스의 인스턴스를 생성할 수 있다.

이밖에도 난수를 생성하는 Random 클래스의 메서드에는 여러가지가 있다.
- nextBoolean()
  - true / false 생성 
- nextInt()
  - -2147483648 ~ + 2147483647
- nextInt(n)
  - 0 ~ n-1 
- nextLong()
  - -9223372036854775808 ~ + 9223372036854775807
- nextDouble()
  - 0.0 이상 1.0 미만 
- nextFloat()
  - 0.0 이상 1.0 미만 

**사실 컴퓨터에서 생성하는 난수는 진짜 난수가 아니다..**
특정 입력값이나 컴퓨터 환경에 따라 무작위로 선택한 것처럼 보이는 난수를 생성하지만 사실 컴퓨터가 생성하는 난수는 모두 컴퓨터가 미리 계산해 둔 의사 난수이다. 

## 배열 요소를 역순으로 정렬하기
배열 요소를 역순으로 정렬하는 알고리즘을 보자. 맨 앞의 요소와 맨 뒤의 요소의 값을 교환하고 점차 안쪽 값들을 교환하면 교환 횟수는 `요소 개수 / 2`가 된다. 요소 개수가 홀수인 경우 가운데 요소는 교환할 필요가 없기 때문에 이 나눗셈의 나머지는 버린다.

따라서 요소 개수가 n인 배열 요소를 역순으로 정렬하는 알고리즘을 간단히 표현하면 아래와 같다.
```agsl
for(i = 0; i < n / 2; i++)
```

### 두 값의 교환
그럼 이제 두 값은 어떻게 교환하는지 알아보자. 교환 요소가 `a[idx1]`, `a[idx2]`라면 값의 교환은 아래와 같이 할 수 있다.
```agsl
t = a[idx1];
a[idx1] = a[idx2];
a[idx2] = t;
```

결국 독립적인 메소드로 구현한 swap은 아래와 같다
```agsl
static void swap(int[] a, int idx1, int idx2) {
    int t = a[idx1]; 
    a[idx1] = a[idx2]; 
    a[idx2] = t;
}
```

## 두 배열의 비교
이제는 여러 배열을 비교해보자. 두 배열의 모든 요소의 값이 같은지 판단하는 메서드를 구현한다.
1. 두 배열 a, b의 요솟수(길이)를 비교한다. 배열의 길이가 다르면 바로 배열이 같지 않다는 것이 분명해져 false를 반환한다.
2. 위의 for문은 두 배열을 스캔하며 요소 a[i], b[i] 값을 비교한다. 이 과정에서 값이 다른 요소가 발견되면 false를 반환한다.
3. 위의 두 경우를 모두 지나친다면 for문이 중단되지 않고 끝까지 실행된 경우이다. 두 배열은 같다고 판단할 수 있으므로 true를 반환한다.

## 기수 변환
정숫값을 임의의 기수로 변환하는 알고리즘을 보자. 10진수 정수를 n진수 정수로 변환하려면 정수를 n으로 나눈 나머지를 구하고, 그 몫에 대해 나눗셈을 반복해야 한다.<br>
몫이 0이 될 때까지 이 과정을 반복하고, 이 과정으로 구한 나머지를 거꾸로 늘어놓은 숫자가 기수로 변환한 숫자이다. 

16진수는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F로 표현되는 수이다.<br>
기수가 10단위를 넘는 경우 0~9에 이어지는 숫자로 알파벳 문자인 A, B, ...를 사용한다. A, B는 10진수의 10, 11, ..에 해당한다.

### 기수란?
**기수의 의미** <br>
수를 나타내는 데 기초가 되는 수로, 10진법에서는 0에서 9까지의 정수를 말한다. 서수는 순서를 나타내는 수다. 기수가 일, 이, 삼이라면 서수는 첫째, 둘째, 셋째 ..
<br>

**정수 상수의 n진수 표현 방법** <br>
정수 상수는 정수 계열의 값을 나타내는 10진수(기수 10), 8진수(기수 8) 또는 16진수(기수 16)를 말한다. 정수 상수는 변경할 수 없는 정숫값을 나타낼 때 사용한다.<br>
정수 상수가 0x 또는 0X로 시작되는 경우는 16진수이고, 숫자 0으로 시작되는 경우는 8진수이다. 두 경우에 해당하지 않으면 10진수로 간주한다.
```agsl
0x1C // 10진수 28에 대한 16진수 표기
034  // 10진수 28에 대한 8진수 표기
```

n진수는 n을 기수로 하는 수이다. 10진수, 8진수, 16진수를 통해 기수에 대해 살펴보자.

**10진수**<br>
10진수(Decimal)는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9의 10종류의 숫자를 사용해 수를 나타낸다.
1234 = 1 * 10^3 + 2 * 10^2 + 3 * 10^1 + 4 * 10^0

**8진수**<br>
8진수(Octal) 는 0, 1, 2, 3, 4, 5, 6, 7 8종류의 숫자를 사용해 수를 나타낸다.
5306 = 5 * 8^3 + 3 * 8^2 + 0 * 8^1 + 6 * 8^0

**16진수**<br>
16진수(Hexadecimal)는 아래 16종류의 문자를 사용해 수를 나타낸다.
```agsl
0 1 2 3 4 5 6 7 8 9 A B C D E F 
```
0~F는 10진수 0~15에 해당한다. 이 숫자를 모두 사용하면 자릿수가 한 자리 올라가 10이 된다. 2자리 숫자는 10부터 FF까지이다. 이 2자리 숫자를 다 사용한 다음의 수는 100이다.

```agsl
12A0 = 1 * 16^3 + 2 * 16^2 + 10 * 16^1 + 0 * 16^0
```
<br>

실습 `CardConv.java`는 기수 변환을 수행하는 프로그램이다. 정수 x를 r진수로 변환한 숫자 문자를 char형 배열 d에 넣어 두고 그 자릿수(배열에 넣어 둔 문자 수)를 반환한다. 
`cardConv` 메서드의 맨 앞에서 초기화되는 `digits`는 변환한 수의 자릿수를 나타내기 위한 변수이다. <br>
`cardConv` 메서드의 첫번째 do문에서 루프 본문은
1. x를 r로 나눈 나머지를 인덱스로 하는 문자를 배열 d의 요소 `d[digits]`에 대입하고 `digits`값을 1 증가시킨다.
2. x를 r로 나눈다.
이 작업을 x가 0이 될 때까지 반복한다.
배열 d의 문자열은 나머지를 구하는 순서대로 넣어두기 때문에 배열의 앞 요소가 변환된 진수의 아랫자리에 해당한다. 즉, 기수 변환 후의 자리 순서는 배열의 본래 자리의 역순이다.
<br>
`main` 메서드는 대화식으로 기수를 변환하고 메서드 `cardConv`에서 반환한 값이 대입되는 변수 `dno`에는 변환한 후의 자릿수가 들어 있다. 변환 후 각 자리의 character는 배열 `cno`의 요소 `cno[0]`부터 `cno[dno - 1]`에 들어 있다. 따라서 마지막 for문에서는 배열 `cno`를 스캔하면서 변환 결과를 나타낸다.

## 소수 나열하기
어떤 정수 이하이 소수를 모두 나열하는 알고리즘을 살펴보자. 소수는 자신과 1 이외 어떤 정수로도 나누어떨어지지 않는 정수이다.<br>
가령 13은 2, 3, ..., 12 중 어느 정수로도 나누어떨어지지 않는다. <br>
```angular2html
소수 : 2부터 n-1 까지의 어떤 정수로도 나누어떨어지지 않는다.
```
만약 나누어떨어지는 정수가 하나 이상 존재하면 그 수는 합성수이다. 1,000 이하의 소수를 나열하는 프로그램을 작성해보자.<br>
```java
package chap02;

// 1,000 이하의 소수를 나열(버전 1)
public class PrimeNumber1 {
    public static void main(String[] args) {
        int counter = 0; // 나눗셈의 횟수

        for(int n = 2; n <= 1000; n++) {
            int i;
            for(i = 2; i < n; i++) {
                counter++;
                if(n % i == 0) {
                    break;
                }
            }
            if(n == i) {
                System.out.println(n);
            }
        }
        System.out.println("나눗셈을 수행한 횟수 : " + counter);
    }
}

```
바깥 for문에서는 n값을 2부터 1000까지 증가시키면서 그 n 값이 소수인지를 판단한다. 안쪽 for문의 반복이 종료된 시점에서 변수 i값은 다음과 같다.<br>
```
- n이 소수인 경우: n과 같은 값 (for문이 끝까지 실행됨)
- n이 합성수인 경우: n보다 작은 값 (for문이 중단됨)
```
나눗셈을 할 때마다 변수 counter가 증가해 연산 횟수를 계산하고.. 나눗셈을 실행한 횟수는 총 78,022회가 된다. 
<br>
그런데 n이 2 또는 3으로 나누어 떨어지지 않으면 2 * 3인 6 또는 2 * 2인 4로도 나누어 떨어지지 않는다. 따라서 이 프로그램은 불필요한 나눗셈을 하고 있다. 즉, 정수 n이 소수인지의 여부는...
```
2부터 n - 1까지의 어떤 소수로도 나누어떨어지지 않는다.
```
이 조건을 만족하는지 조사하면 된다. 가령 7이 소수인지는 7보다 작은 소수 2, 3, 5로 나눗셈을 하면 충분하고, 2, 3, 4, 5, 6, 7로 불필요한 나눗셈을 할 필요가 없다. 

### 알고리즘 개선하기 1