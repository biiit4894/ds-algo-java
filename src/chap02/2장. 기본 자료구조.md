# 02-1 배열

## 자료구조
- 데이터 단위 : 데이터를 구성하는 한 덩어리
- 자료구조 : 자료를 효율적으로 이용하도록 적재하는 법

## 배열
- 같은 자료형의 변수로 이루어진 구성요소가 모인 것.
- 가령 `int[]a = new int[5];` 의 경우 int형의 배열 본체를 생성하고 배열 a가 그것을 참조하도록 설정하는 것이다. 

### 구성 요소
- 배열 내 모든 구성 요소의 형태는 같고 직선 모양으로 줄지어 있음. 정수형 인덱스로 각 요소에 접근.
- 자동으로 0으로 초기화된다.
- 배열을 생성할 때의 초기값
  - byte형 : (byte)0
  - short형 : (short)0
  - int형 : 0
  - long형 : 0L
  - float형 : 0.0f
  - double형 : 0.0d
  - char형 : `\u0000`
  - boolean형 : false
  - 참조형 : 공백 참조 or null값

### 배열의 길이
- `배열 변수 이름.length`로 길이에 접근

**참고** <br>
배열의 자료형과 배열 각 요소의 자료형은 다르다! 위에 나온 배열 a의 자료형은 int[5]형이지만 각 요소 하나 하나의 자료형은 int형이다. 
<br><br>
**값을 대입하지 않은 지역변수**<br>
메서드 안에서 선언한 지역변수는 변수를 만들어도 초깃값으로 초기화되지 않는다. 
```agsl
int a;
System.out.println(a); // compile error
```

### 배열의 요솟값 초기화
```agsl
int[] a = {1, 2, 3, 4 ,5};
```
배열 본체의 생성과 동시에 요소를 모두 초기화함

### 배열의 복제
`배열 이름.clone()`
가령 이미 초기값 설정까지 완료된 int형이 모인 배열 a를 배열 b가 clone한다면, 배열 변수 b는 a가 참조하는 배열 본체의 **복제**를 참조한다. 

## 배열 요소의 최댓값 구하기
- 주사(traverse, 스캔): 배열의 요소를 하나씩 차례로 살펴보는 과정
  - 데이터를 하나씩 지나면서 살피고 조사하는 것.

배열 모든 요소에 대해 스캔을 완료한 시점에 최대 요솟값을 최대값 변수에 대입하면 된다.

### 배열 요소의 최댓값을 구하는 메서드
**참고 : 메서드의 매개변수로 배열 사용하기** <br>
예제의 `MaxOfArray.java` 코드에서, 마지막의 `maxOf(height)`를 보자. 배열 height의 최댓값을 구하기 위해 maxOf 메서드를 호출한다. 
인수로 들어간 height는 배열 본체를 참조하는 배열 변수이고, maxOf에 전달되는 것은 배열 본체에 대한 참조가 된다. 
maxOf에서는 배열 변수인 매개변수 a가 전달받은 참조로 초기화되고, 배열 변수 a는 배열 height의 본체를 참조한다. 
결과적으로 maxOf 안의 배열 a는 main 메서드의 배열 height인 셈이 된다. 
이로 인해 메서드 maxOf는 매개변수 a가 전달받은 참조 덕분에 배열의 요솟수와 각 요소에 접근할 수 있다.

### 난수를 사용해 배열의 요솟값 설정하기
`MaxOfArrayRand.java` 코드는 배열의 각 요소에 난수를 대입하고 있다. `Random rand = new Random();` 코드로 Random 클래스형의 변수를 만들기 위한 선언을 하고, 
`rand.nextInt(90);`으로 변수 rand에 대한 난수를 생성하는 메소드 `nextInt`를 호출한다. `nextInt(n)`은 0 ~ (n-1)까지의 난수를 반환한다.

**난수의 생성** <br>
java.util 패키지의 Random 클래스. 이 클래스의 인스턴스는 일련의 의사 난수를 생성하고 이 난수는 seed라는 수의 값을 바탕으로 연산과정을 거쳐 도출된다. 
`Random rand = new Random();` 또는 `Random rand = new Random(n)` 방식으로 Random 클래스의 인스턴스를 생성할 수 있다.

이밖에도 난수를 생성하는 Random 클래스의 메서드에는 여러가지가 있다.
- nextBoolean()
  - true / false 생성 
- nextInt()
  - -2147483648 ~ + 2147483647
- nextInt(n)
  - 0 ~ n-1 
- nextLong()
  - -9223372036854775808 ~ + 9223372036854775807
- nextDouble()
  - 0.0 이상 1.0 미만 
- nextFloat()
  - 0.0 이상 1.0 미만 

**사실 컴퓨터에서 생성하는 난수는 진짜 난수가 아니다..**
특정 입력값이나 컴퓨터 환경에 따라 무작위로 선택한 것처럼 보이는 난수를 생성하지만 사실 컴퓨터가 생성하는 난수는 모두 컴퓨터가 미리 계산해 둔 의사 난수이다. 

## 배열 요소를 역순으로 정렬하기
배열 요소를 역순으로 정렬하는 알고리즘을 보자. 맨 앞의 요소와 맨 뒤의 요소의 값을 교환하고 점차 안쪽 값들을 교환하면 교환 횟수는 `요소 개수 / 2`가 된다. 요소 개수가 홀수인 경우 가운데 요소는 교환할 필요가 없기 때문에 이 나눗셈의 나머지는 버린다.

따라서 요소 개수가 n인 배열 요소를 역순으로 정렬하는 알고리즘을 간단히 표현하면 아래와 같다.
```agsl
for(i = 0; i < n / 2; i++)
```

### 두 값의 교환
그럼 이제 두 값은 어떻게 교환하는지 알아보자. 교환 요소가 `a[idx1]`, `a[idx2]`라면 값의 교환은 아래와 같이 할 수 있다.
```agsl
t = a[idx1];
a[idx1] = a[idx2];
a[idx2] = t;
```

결국 독립적인 메소드로 구현한 swap은 아래와 같다
```agsl
static void swap(int[] a, int idx1, int idx2) {
    int t = a[idx1]; 
    a[idx1] = a[idx2]; 
    a[idx2] = t;
}
```